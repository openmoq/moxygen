name: OpenMOQ Upstream Sync

# Implements GITHUB_WORKFLOW.md Section 1: Upstream Moxygen Dependency Approach
# Detects qualifying upstream changes, creates a candidate branch with local
# patches applied, and opens a PR for CI validation + auto-merge.

on:
  schedule:
    - cron: '0 7 * * *'   # Daily at 02:00 ET (07:00 UTC)
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write
  workflows: write      # needed to push upstream changes to .github/workflows/

jobs:
  sync:
    runs-on: ubuntu-22.04
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      # ── Step 1: Check upstream for qualifying changes ──
      - name: Check upstream status
        id: upstream
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Get latest commit on upstream main
          UPSTREAM_SHA=$(gh api repos/facebookexperimental/moxygen/commits/main -q .sha)
          echo "upstream_sha=$UPSTREAM_SHA" >> "$GITHUB_OUTPUT"
          echo "Upstream HEAD: $UPSTREAM_SHA"

          # Check if this commit has passing CI via check-suites
          # (Meta repos use GitHub Actions check suites, not the commit status API)
          STATE=$(gh api "repos/facebookexperimental/moxygen/commits/$UPSTREAM_SHA/check-suites" \
            -q '[.check_suites[] | select(.app.name=="GitHub Actions")] |
                if length == 0 then "failure"
                elif any(.status == "queued" or .status == "in_progress") then "pending"
                elif all(.conclusion == "success") then "success"
                else "failure" end')
          echo "Upstream check-suites status: $STATE"

          # Log individual check-run results for visibility
          echo "--- Upstream check-runs ---"
          gh api "repos/facebookexperimental/moxygen/commits/$UPSTREAM_SHA/check-runs" \
            -q '.check_runs[] | "[\(.conclusion // .status)] \(.name)"'
          echo "---"

          if [ "$STATE" != "success" ]; then
            echo "Upstream is $STATE (not success). Skipping."
            echo "should_sync=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Check if we already have this commit (merged or as an open candidate PR)
          if git merge-base --is-ancestor "$UPSTREAM_SHA" HEAD 2>/dev/null; then
            echo "Already integrated. Nothing to do."
            echo "should_sync=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Check if a candidate branch already exists for this SHA
          SHORT_SHA="${UPSTREAM_SHA:0:12}"
          if git ls-remote --heads origin "sync-upstream-${SHORT_SHA}" | grep -q .; then
            echo "Candidate branch sync-upstream-${SHORT_SHA} already exists."
            echo "should_sync=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "should_sync=true" >> "$GITHUB_OUTPUT"
          echo "short_sha=${SHORT_SHA}" >> "$GITHUB_OUTPUT"

      # ── Step 2: Create candidate branch and merge upstream ──
      - name: Add upstream remote
        if: steps.upstream.outputs.should_sync == 'true'
        run: |
          git remote add upstream https://github.com/facebookexperimental/moxygen.git || true
          git fetch upstream main

      - name: Create candidate branch
        if: steps.upstream.outputs.should_sync == 'true'
        id: merge
        run: |
          BRANCH="sync-upstream-${{ steps.upstream.outputs.short_sha }}"
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          git checkout -b "$BRANCH"

          # Attempt merge — if clean, we're done
          if git merge --no-ff upstream/main \
               -m "Merge upstream moxygen ${{ steps.upstream.outputs.short_sha }}"; then
            echo "Merge completed cleanly."
            echo "conflicts_resolved=0" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Merge has conflicts — auto-resolve upstream-owned files, protect ours
          echo "Merge conflicts detected. Attempting auto-resolution..."
          CONFLICTS=$(git diff --name-only --diff-filter=U)
          RESOLVED=0
          OPENMOQ_CONFLICT=false

          for file in $CONFLICTS; do
            case "$file" in
              openmoq/*|.github/workflows/openmoq-*)
                echo "::error::Conflict in OpenMOQ-owned file: $file (requires manual resolution)"
                OPENMOQ_CONFLICT=true
                ;;
              *)
                echo "Auto-resolving (taking upstream): $file"
                git checkout --theirs "$file"
                git add "$file"
                RESOLVED=$((RESOLVED + 1))
                ;;
            esac
          done

          if [ "$OPENMOQ_CONFLICT" = true ]; then
            echo "::error::Conflicts in OpenMOQ-owned files cannot be auto-resolved"
            git merge --abort
            exit 1
          fi

          # Complete the merge commit
          git commit --no-edit
          echo "Auto-resolved $RESOLVED conflict(s) in upstream-owned files."
          echo "conflicts_resolved=$RESOLVED" >> "$GITHUB_OUTPUT"

      # ── Step 3: Apply local patches from openmoq/patches/ ──
      - name: Apply OpenMOQ patches
        id: patches
        if: steps.upstream.outputs.should_sync == 'true'
        run: |
          PATCH_DIR="openmoq/patches"
          if [ ! -d "$PATCH_DIR" ] || [ -z "$(ls -A "$PATCH_DIR"/*.patch 2>/dev/null)" ]; then
            echo "No patches to apply."
            echo "patches_applied=0" >> "$GITHUB_OUTPUT"
            echo "patches_skipped=0" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          APPLIED=0
          SKIPPED=0
          MERGED=0
          SKIPPED_LIST=""
          for patch in "$PATCH_DIR"/*.patch; do
            BASENAME=$(basename "$patch")

            # 1) Clean apply — patch applies exactly as written
            if git apply --check "$patch" 2>/dev/null; then
              echo "Applying: $BASENAME"
              if ! git am "$patch"; then
                echo "::error::Patch failed during apply: $BASENAME"
                git am --abort
                echo "patch_failed=true" >> "$GITHUB_OUTPUT"
                echo "failed_patch=$BASENAME" >> "$GITHUB_OUTPUT"
                exit 1
              fi
              APPLIED=$((APPLIED + 1))

            # 2) Fully absorbed — every hunk already present upstream
            elif git apply --reverse --check "$patch" 2>/dev/null; then
              echo "Skipping (already applied upstream): $BASENAME"
              SKIPPED=$((SKIPPED + 1))
              SKIPPED_LIST="${SKIPPED_LIST}${BASENAME}, "

            # 3) Partial overlap — some hunks applied, some not. Use 3-way merge.
            elif git am --3way "$patch" 2>/dev/null; then
              echo "Applied with 3-way merge (partial upstream overlap): $BASENAME"
              MERGED=$((MERGED + 1))

            else
              git am --abort 2>/dev/null || true
              echo "::error::Patch cannot apply (clean, skip, or 3-way): $BASENAME"
              echo "patch_failed=true" >> "$GITHUB_OUTPUT"
              echo "failed_patch=$BASENAME" >> "$GITHUB_OUTPUT"
              exit 1
            fi
          done

          echo "patches_applied=$APPLIED" >> "$GITHUB_OUTPUT"
          echo "patches_merged=$MERGED" >> "$GITHUB_OUTPUT"
          echo "patches_skipped=$SKIPPED" >> "$GITHUB_OUTPUT"
          echo "patches_skipped_list=${SKIPPED_LIST%, }" >> "$GITHUB_OUTPUT"
          echo "Applied $APPLIED, 3-way merged $MERGED, skipped $SKIPPED (already upstream)."

      # ── Step 4: Push candidate branch and create PR ──
      - name: Push candidate branch
        if: steps.upstream.outputs.should_sync == 'true'
        run: |
          BRANCH="sync-upstream-${{ steps.upstream.outputs.short_sha }}"
          git push origin "$BRANCH"

      - name: Create candidate PR
        if: steps.upstream.outputs.should_sync == 'true'
        id: pr
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          BRANCH="sync-upstream-${{ steps.upstream.outputs.short_sha }}"
          UPSTREAM_SHA="${{ steps.upstream.outputs.upstream_sha }}"
          APPLIED="${{ steps.patches.outputs.patches_applied }}"
          SKIPPED="${{ steps.patches.outputs.patches_skipped }}"
          SKIPPED_LIST="${{ steps.patches.outputs.patches_skipped_list }}"
          CONFLICTS="${{ steps.merge.outputs.conflicts_resolved }}"

          # Build details section
          DETAILS=""
          if [ "${CONFLICTS:-0}" -gt 0 ]; then
            DETAILS="${DETAILS}\n- **Merge conflicts auto-resolved:** ${CONFLICTS} (upstream-owned files)"
          fi
          if [ -n "$SKIPPED_LIST" ]; then
            DETAILS="${DETAILS}\n- **Patches skipped (already upstream):** ${SKIPPED_LIST}"
          fi

          PR_URL=$(gh pr create \
            --head "$BRANCH" \
            --base main \
            --title "sync: upstream moxygen ${{ steps.upstream.outputs.short_sha }}" \
            --body "$(cat <<EOF
          Automated upstream sync.

          - **Upstream commit:** [\`${UPSTREAM_SHA:0:12}\`](https://github.com/facebookexperimental/moxygen/commit/$UPSTREAM_SHA)
          - **Upstream status:** success (green)
          - **Patches applied:** ${APPLIED:-0}${DETAILS}

          The existing \`getdeps_linux\` and \`getdeps_mac\` workflows will validate this branch.
          On CI success, this PR will be auto-merged.

          Created by \`openmoq-upstream-sync\` workflow.
          EOF
          )")

          echo "pr_url=$PR_URL" >> "$GITHUB_OUTPUT"
          echo "Created PR: $PR_URL"

      # ── Step 5: Enable auto-merge ──
      - name: Enable auto-merge
        if: steps.upstream.outputs.should_sync == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          BRANCH="sync-upstream-${{ steps.upstream.outputs.short_sha }}"
          PR_NUM=$(gh pr list --head "$BRANCH" --json number --jq '.[0].number')
          if [ -n "$PR_NUM" ]; then
            gh pr merge "$PR_NUM" --auto --merge || echo "Auto-merge not available (branch protection may not be configured)."
          fi

      # ── Notifications ──
      - name: Notify Slack (candidate created)
        if: steps.upstream.outputs.should_sync == 'true'
        uses: slackapi/slack-github-action@v1.26
        with:
          payload: |
            {
              "channel": "#github-notifications",
              "text": ":arrows_counterclockwise: *moxygen upstream sync* — candidate PR created\nUpstream: `${{ steps.upstream.outputs.upstream_sha }}`\nPatches applied: ${{ steps.patches.outputs.patches_applied || '0' }}, skipped: ${{ steps.patches.outputs.patches_skipped || '0' }}\nConflicts auto-resolved: ${{ steps.merge.outputs.conflicts_resolved || '0' }}\n<${{ steps.pr.outputs.pr_url }}|View PR>"
            }
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}

      - name: Notify Slack (patch failure)
        if: failure() && steps.patches.outputs.patch_failed == 'true'
        uses: slackapi/slack-github-action@v1.26
        with:
          payload: |
            {
              "channel": "#github-notifications",
              "text": ":x: *moxygen upstream sync FAILED* — patch application error\nUpstream: `${{ steps.upstream.outputs.upstream_sha }}`\nFailed patch: `${{ steps.patches.outputs.failed_patch }}`\n<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View run>"
            }
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}

      - name: Notify email (candidate created)
        if: steps.upstream.outputs.should_sync == 'true'
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: ${{ secrets.SMTP_SERVER }}
          server_port: ${{ secrets.SMTP_PORT }}
          username: ${{ secrets.SMTP_USERNAME }}
          password: ${{ secrets.SMTP_PASSWORD }}
          subject: "[moxygen] upstream sync — candidate PR created"
          to: github-notifications@openmoq.org
          from: github-ci@openmoq.org
          body: |
            Upstream sync candidate PR created for openmoq/moxygen.

            Upstream commit: ${{ steps.upstream.outputs.upstream_sha }}
            Patches applied: ${{ steps.patches.outputs.patches_applied || '0' }}
            PR: ${{ steps.pr.outputs.pr_url }}
