name: OpenMOQ Upstream Sync

# Implements GITHUB_WORKFLOW.md Section 1: Upstream Moxygen Dependency Approach
# Detects qualifying upstream changes, creates a candidate branch with local
# patches applied, and opens a PR for CI validation + auto-merge.

on:
  schedule:
    - cron: '0 7 * * *'   # Daily at 02:00 ET (07:00 UTC)
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write

jobs:
  sync:
    runs-on: ubuntu-22.04
    steps:
      # PAT with 'workflow' scope required to push upstream changes to
      # .github/workflows/ files. GITHUB_TOKEN cannot modify workflow files.
      # Falls back to GITHUB_TOKEN if SYNC_PAT is not configured.
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.OMOQ_SYNC_TOKEN || secrets.GITHUB_TOKEN }}

      # ── Step 1: Check upstream for qualifying changes ──
      - name: Check upstream status
        id: upstream
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Walk recent upstream commits (newest first) and find the latest
          # one with passing CI that we haven't already integrated.
          COMMITS=$(gh api 'repos/facebookexperimental/moxygen/commits?per_page=20' \
            --jq '.[].sha')

          echo "Scanning up to 20 recent upstream commits..."
          UPSTREAM_SHA=""

          for SHA in $COMMITS; do
            SHORT="${SHA:0:12}"

            # Skip if already integrated
            if git merge-base --is-ancestor "$SHA" HEAD 2>/dev/null; then
              echo "  $SHORT: already integrated (stopping scan)"
              break
            fi

            # Skip if candidate branch already exists
            if git ls-remote --heads origin "sync-upstream-${SHORT}" | grep -q .; then
              echo "  $SHORT: candidate branch already exists (skipping)"
              continue
            fi

            # Check CI status via check-suites
            STATE=$(gh api "repos/facebookexperimental/moxygen/commits/$SHA/check-suites" \
              -q '[.check_suites[] | select(.app.name=="GitHub Actions")] |
                  if length == 0 then "failure"
                  elif any(.status == "queued" or .status == "in_progress") then "pending"
                  elif all(.conclusion == "success") then "success"
                  else "failure" end')

            echo "  $SHORT: $STATE"

            if [ "$STATE" = "success" ]; then
              UPSTREAM_SHA="$SHA"
              break
            fi
          done

          if [ -z "$UPSTREAM_SHA" ]; then
            echo "No qualifying upstream commit found. Skipping."
            echo "should_sync=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          SHORT_SHA="${UPSTREAM_SHA:0:12}"
          echo ""
          echo "Selected upstream commit: $SHORT_SHA"

          # Log check-runs for the selected commit
          echo "--- Check-runs for $SHORT_SHA ---"
          gh api "repos/facebookexperimental/moxygen/commits/$UPSTREAM_SHA/check-runs" \
            -q '.check_runs[] | "[\(.conclusion // .status)] \(.name)"'
          echo "---"

          echo "upstream_sha=$UPSTREAM_SHA" >> "$GITHUB_OUTPUT"
          echo "short_sha=${SHORT_SHA}" >> "$GITHUB_OUTPUT"
          echo "should_sync=true" >> "$GITHUB_OUTPUT"

      # ── Step 2: Create candidate branch and merge upstream ──
      - name: Add upstream remote
        if: steps.upstream.outputs.should_sync == 'true'
        run: |
          git remote add upstream https://github.com/facebookexperimental/moxygen.git || true
          git fetch upstream main

      - name: Create candidate branch
        if: steps.upstream.outputs.should_sync == 'true'
        id: merge
        run: |
          BRANCH="sync-upstream-${{ steps.upstream.outputs.short_sha }}"
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          git checkout -b "$BRANCH"

          # Attempt merge — if clean, we're done
          if git merge --no-ff upstream/main \
               -m "Merge upstream moxygen ${{ steps.upstream.outputs.short_sha }}"; then
            echo "Merge completed cleanly."
            echo "conflicts_resolved=0" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Merge has conflicts — auto-resolve upstream-owned files, protect ours
          echo "Merge conflicts detected. Attempting auto-resolution..."
          CONFLICTS=$(git diff --name-only --diff-filter=U)
          RESOLVED=0
          OPENMOQ_CONFLICT=false

          for file in $CONFLICTS; do
            case "$file" in
              openmoq/*|.github/workflows/openmoq-*)
                echo "::error::Conflict in OpenMOQ-owned file: $file (requires manual resolution)"
                OPENMOQ_CONFLICT=true
                ;;
              *)
                echo "Auto-resolving (taking upstream): $file"
                git checkout --theirs "$file"
                git add "$file"
                RESOLVED=$((RESOLVED + 1))
                ;;
            esac
          done

          if [ "$OPENMOQ_CONFLICT" = true ]; then
            echo "::error::Conflicts in OpenMOQ-owned files cannot be auto-resolved"
            git merge --abort
            exit 1
          fi

          # Complete the merge commit
          git commit --no-edit
          echo "Auto-resolved $RESOLVED conflict(s) in upstream-owned files."
          echo "conflicts_resolved=$RESOLVED" >> "$GITHUB_OUTPUT"

      # ── Step 3: Apply local patches from openmoq/patches/ ──
      - name: Apply OpenMOQ patches
        id: patches
        if: steps.upstream.outputs.should_sync == 'true'
        run: |
          PATCH_DIR="openmoq/patches"
          if [ ! -d "$PATCH_DIR" ] || [ -z "$(ls -A "$PATCH_DIR"/*.patch 2>/dev/null)" ]; then
            echo "No patches to apply."
            echo "patches_applied=0" >> "$GITHUB_OUTPUT"
            echo "patches_skipped=0" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          APPLIED=0
          SKIPPED=0
          MERGED=0
          SKIPPED_LIST=""
          for patch in "$PATCH_DIR"/*.patch; do
            BASENAME=$(basename "$patch")

            # 1) Clean apply — patch applies exactly as written
            if git apply --check "$patch" 2>/dev/null; then
              echo "Applying: $BASENAME"
              if ! git am "$patch"; then
                echo "::error::Patch failed during apply: $BASENAME"
                git am --abort
                echo "patch_failed=true" >> "$GITHUB_OUTPUT"
                echo "failed_patch=$BASENAME" >> "$GITHUB_OUTPUT"
                exit 1
              fi
              APPLIED=$((APPLIED + 1))

            # 2) Fully absorbed — every hunk already present upstream
            elif git apply --reverse --check "$patch" 2>/dev/null; then
              echo "Skipping (already applied upstream): $BASENAME"
              SKIPPED=$((SKIPPED + 1))
              SKIPPED_LIST="${SKIPPED_LIST}${BASENAME}, "

            # 3) Partial overlap — some hunks applied, some not. Use 3-way merge.
            elif git am --3way "$patch" 2>/dev/null; then
              echo "Applied with 3-way merge (partial upstream overlap): $BASENAME"
              MERGED=$((MERGED + 1))

            else
              git am --abort 2>/dev/null || true
              echo "::error::Patch cannot apply (clean, skip, or 3-way): $BASENAME"
              echo "patch_failed=true" >> "$GITHUB_OUTPUT"
              echo "failed_patch=$BASENAME" >> "$GITHUB_OUTPUT"
              exit 1
            fi
          done

          echo "patches_applied=$APPLIED" >> "$GITHUB_OUTPUT"
          echo "patches_merged=$MERGED" >> "$GITHUB_OUTPUT"
          echo "patches_skipped=$SKIPPED" >> "$GITHUB_OUTPUT"
          echo "patches_skipped_list=${SKIPPED_LIST%, }" >> "$GITHUB_OUTPUT"
          echo "Applied $APPLIED, 3-way merged $MERGED, skipped $SKIPPED (already upstream)."

      # ── Step 4: Push candidate branch and create PR ──
      - name: Push candidate branch
        if: steps.upstream.outputs.should_sync == 'true'
        run: |
          BRANCH="sync-upstream-${{ steps.upstream.outputs.short_sha }}"
          git push origin "$BRANCH"

      - name: Close stale sync PRs
        if: steps.upstream.outputs.should_sync == 'true'
        env:
          GH_TOKEN: ${{ secrets.OMOQ_SYNC_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          NEW_BRANCH="sync-upstream-${{ steps.upstream.outputs.short_sha }}"
          # Close any open sync PRs targeting a different (older) upstream commit
          gh api repos/${{ github.repository }}/pulls?state=open \
            --jq '.[] | select(.head.ref | startswith("sync-upstream-")) | "\(.number) \(.head.ref)"' \
          | while read -r NUM REF; do
              if [ "$REF" != "$NEW_BRANCH" ]; then
                echo "Closing stale sync PR #$NUM ($REF)"
                gh api repos/${{ github.repository }}/pulls/$NUM \
                  -X PATCH -f state=closed || true
                # Delete the stale branch
                gh api repos/${{ github.repository }}/git/refs/heads/$REF \
                  -X DELETE || true
              fi
            done

      - name: Create candidate PR
        if: steps.upstream.outputs.should_sync == 'true'
        id: pr
        env:
          GH_TOKEN: ${{ secrets.OMOQ_SYNC_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          BRANCH="sync-upstream-${{ steps.upstream.outputs.short_sha }}"
          UPSTREAM_SHA="${{ steps.upstream.outputs.upstream_sha }}"
          APPLIED="${{ steps.patches.outputs.patches_applied }}"
          SKIPPED="${{ steps.patches.outputs.patches_skipped }}"
          SKIPPED_LIST="${{ steps.patches.outputs.patches_skipped_list }}"
          CONFLICTS="${{ steps.merge.outputs.conflicts_resolved }}"

          # Build details section
          DETAILS=""
          if [ "${CONFLICTS:-0}" -gt 0 ]; then
            DETAILS="${DETAILS}\n- **Merge conflicts auto-resolved:** ${CONFLICTS} (upstream-owned files)"
          fi
          if [ -n "$SKIPPED_LIST" ]; then
            DETAILS="${DETAILS}\n- **Patches skipped (already upstream):** ${SKIPPED_LIST}"
          fi

          # Use REST API for PR creation — GraphQL createPullRequest is
          # blocked on fork repos for both GITHUB_TOKEN and fine-grained PATs.
          BODY=$(cat <<EOF
          Automated upstream sync.

          - **Upstream commit:** [\`${UPSTREAM_SHA:0:12}\`](https://github.com/facebookexperimental/moxygen/commit/$UPSTREAM_SHA)
          - **Upstream status:** success (green)
          - **Patches applied:** ${APPLIED:-0}${DETAILS}

          The existing \`getdeps_linux\` and \`getdeps_mac\` workflows will validate this branch.
          On CI success, this PR will be auto-merged.

          Created by \`openmoq-upstream-sync\` workflow.
          EOF
          )

          PR_URL=$(gh api repos/${{ github.repository }}/pulls \
            -f title="sync: upstream moxygen ${{ steps.upstream.outputs.short_sha }}" \
            -f body="$BODY" \
            -f head="$BRANCH" \
            -f base="main" \
            --jq '.html_url')

          echo "pr_url=$PR_URL" >> "$GITHUB_OUTPUT"
          echo "Created PR: $PR_URL"

      # ── Step 5: Wait for CI and merge ──
      - name: Wait for CI checks and merge
        if: steps.upstream.outputs.should_sync == 'true'
        env:
          GH_TOKEN: ${{ secrets.OMOQ_SYNC_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          BRANCH="sync-upstream-${{ steps.upstream.outputs.short_sha }}"
          PR_NUM=$(gh api repos/${{ github.repository }}/pulls \
            --jq ".[] | select(.head.ref==\"$BRANCH\") | .number")

          if [ -z "$PR_NUM" ]; then
            echo "::error::Could not find PR for branch $BRANCH"
            exit 1
          fi

          echo "Waiting for CI checks on PR #$PR_NUM (up to 90 minutes)..."
          MAX_WAIT=5400  # 90 minutes
          INTERVAL=60    # check every 60 seconds
          ELAPSED=0

          while [ $ELAPSED -lt $MAX_WAIT ]; do
            sleep $INTERVAL
            ELAPSED=$((ELAPSED + INTERVAL))

            # Get combined check status for the PR head
            STATUS=$(gh api repos/${{ github.repository }}/commits/$BRANCH/status \
              --jq '.state')

            echo "  ${ELAPSED}s: status=$STATUS"

            if [ "$STATUS" = "success" ]; then
              echo "CI passed. Merging PR #$PR_NUM..."
              gh api repos/${{ github.repository }}/pulls/$PR_NUM/merge \
                -X PUT \
                -f merge_method=merge \
                --jq '.message'
              echo "Merged successfully."
              exit 0
            elif [ "$STATUS" = "failure" ] || [ "$STATUS" = "error" ]; then
              echo "::warning::CI failed on PR #$PR_NUM. Leaving PR open for manual review."
              exit 0
            fi
            # "pending" — keep waiting
          done

          echo "::warning::CI did not complete within 90 minutes. Leaving PR #$PR_NUM open."

      # ── Notifications (failures only — successful syncs are quiet) ──
      - name: Notify Slack (sync failure)
        if: failure()
        continue-on-error: true
        uses: slackapi/slack-github-action@v1.26
        with:
          payload: |
            {
              "text": ":x: *moxygen upstream sync FAILED*\nUpstream: `${{ steps.upstream.outputs.upstream_sha || 'unknown' }}`\nFailed patch: `${{ steps.patches.outputs.failed_patch || 'n/a' }}`\n<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View run>"
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.OMOQ_SLACK_WEBHOOK_URL }}
